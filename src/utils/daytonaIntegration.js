/**
 * Daytona Integration for LeetCourt
 * Uses Daytona TypeScript SDK to create sandboxes with legal case analysis
 */

import { Daytona } from '@daytonaio/sdk';

// Initialize Daytona SDK
// Uses DAYTONA_API_KEY and DAYTONA_API_URL from environment
const getDaytona = () => {
  const apiKey = import.meta.env.VITE_DAYTONA_API_KEY;
  const apiUrl = import.meta.env.VITE_DAYTONA_API_URL || 'https://app.daytona.io/api';
  const target = import.meta.env.VITE_DAYTONA_TARGET || 'us';

  if (!apiKey) {
    throw new Error('DAYTONA_API_KEY is required. Please set VITE_DAYTONA_API_KEY in your .env file');
  }

  return new Daytona({
    apiKey,
    apiUrl,
    target
  });
};

/**
 * Generate case analysis markdown content
 */
function generateCaseAnalysisMarkdown(caseData) {
  return `# ${caseData.title}

## Case Information
- **Type**: ${caseData.case_type}
- **Difficulty**: ${caseData.difficulty}/5
- **Legal Issue**: ${caseData.issue}

## Facts
${caseData.facts}

## Applicable Statutes
${caseData.statutes}

## Burden of Proof
${caseData.burden_of_proof}

## Strategic Notes
${caseData.notes || 'No strategic notes available.'}

## Evidence
${caseData.evidence?.map((e, i) => `${i + 1}. **${e.name}** (${e.type}): ${e.content}`).join('\n') || 'No evidence listed.'}

## Relevant Precedents
${caseData.precedents?.map((p, i) => `${i + 1}. ${p}`).join('\n') || 'No precedents listed.'}

## Arguments

### Prosecution Argument
${caseData.user_argument}

### Defense Thesis
${caseData.defense_thesis}

---

*Generated by LeetCourt - Master the Art of Argument*
`;
}

/**
 * Generate Python analysis script with AI-powered insights generation using OpenRouter
 */
function generatePythonAnalysisScript(caseData) {
  const openRouterApiKey = import.meta.env.VITE_OPENROUTER_API_KEY || '';
  
  const caseJson = JSON.stringify({
    title: caseData.title,
    case_type: caseData.case_type,
    issue: caseData.issue,
    facts: caseData.facts,
    statutes: caseData.statutes,
    precedents: caseData.precedents || [],
    user_argument: caseData.user_argument,
    defense_thesis: caseData.defense_thesis
  }, null, 2).replace(/"/g, '\\"').replace(/\n/g, '\\n');

  return `#!/usr/bin/env python3
"""
AI-Powered Legal Case Analysis with GPT-4o
Case: ${caseData.title}
Generated by LeetCourt with Daytona Integration
"""

import json
import os
import urllib.request
import urllib.error

# Case data
case_data = json.loads("""${caseJson}""")

OPENROUTER_API_KEY = "${openRouterApiKey}"

def call_openrouter_api():
    """Call OpenRouter API with GPT-4o for intelligent legal analysis"""
    
    prompt = f"""You are an expert legal analyst preparing strategic insights for a courtroom battle. Generate comprehensive legal analysis for this case.

CASE INFORMATION:
Title: {case_data['title']}
Type: {case_data['case_type']}
Legal Issue: {case_data['issue']}
Facts: {case_data['facts']}
Statutes: {case_data.get('statutes', 'Not specified')}

Prosecution Argument: {case_data.get('user_argument', 'Not specified')}
Defense Thesis: {case_data.get('defense_thesis', 'Not specified')}

Generate a comprehensive JSON response with the following structure:

{{
  "notes": "Detailed strategic analysis (4-6 sentences): Analyze the legal theory, burden of proof, key elements to establish, potential weaknesses in opposing arguments, and tactical recommendations for winning this case.",
  "evidence": [
    {{
      "name": "Evidence item name",
      "content": "Detailed description of what this evidence contains and shows",
      "type": "document|video|testimony|physical|expert",
      "relevance": "Detailed explanation of why this evidence is critical and how it proves key elements"
    }}
  ],
  "precedents": [
    "Case Name v. Defendant (Year) - Comprehensive explanation of the legal principle established and detailed analysis of how it directly applies to support arguments in this case"
  ]
}}

REQUIREMENTS:
- Generate 5-8 highly relevant evidence items that cover all aspects of the case
- Include 4-6 applicable precedents with detailed explanations (2-3 sentences each)
- Notes should be comprehensive, tactical, and case-specific (4-6 sentences)
- Evidence should be realistic, varied in type, and strategically important
- Precedents should be real landmark cases with detailed application analysis
- Focus on building a complete legal strategy
- Each item should be detailed and substantive

Return ONLY valid JSON, no markdown formatting."""

    request_data = json.dumps({
        "model": "openai/gpt-4o",
        "messages": [
            {
                "role": "system",
                "content": "You are a legal analyst AI that generates comprehensive strategic insights in JSON format. Always return valid JSON without markdown code blocks."
            },
            {
                "role": "user",
                "content": prompt
            }
        ],
        "temperature": 0.7,
        "max_tokens": 3000
    }).encode('utf-8')

    req = urllib.request.Request(
        'https://openrouter.ai/api/v1/chat/completions',
        data=request_data,
        headers={
            'Authorization': f'Bearer {OPENROUTER_API_KEY}',
            'Content-Type': 'application/json',
            'HTTP-Referer': 'https://leetcourt.app',
            'X-Title': 'LeetCourt'
        }
    )

    try:
        with urllib.request.urlopen(req) as response:
            data = json.loads(response.read().decode('utf-8'))
            content = data['choices'][0]['message']['content']
            
            # Extract JSON from response (handle markdown code blocks)
            json_text = content.strip()
            if json_text.startswith('\`\`\`json'):
                json_text = json_text.replace('\`\`\`json\\n', '').replace('\\n\`\`\`', '')
            elif json_text.startswith('\`\`\`'):
                json_text = json_text.replace('\`\`\`\\n', '').replace('\\n\`\`\`', '')
            
            return json.loads(json_text)
    except urllib.error.HTTPError as e:
        print(f"API Error: {e.code} - {e.read().decode('utf-8')}")
        return None
    except Exception as e:
        print(f"Error calling API: {str(e)}")
        return None

def generate_fallback_analysis():
    """Generate comprehensive fallback analysis based on case data"""
    case_type = case_data.get('case_type', '').lower()
    issue = case_data.get('issue', '').lower()
    
    # Generate detailed notes based on case type
    notes_parts = []
    if 'criminal' in case_type:
        notes_parts.append("Criminal case requiring proof beyond reasonable doubt.")
        notes_parts.append("Prosecution must establish each element of the offense charged.")
        notes_parts.append("Defense should focus on creating reasonable doubt in any element.")
        notes_parts.append("Consider chain of custody for physical evidence and credibility of witnesses.")
    elif 'tort' in case_type or 'negligence' in issue or 'malpractice' in issue:
        notes_parts.append("Tort case requiring proof by preponderance of evidence.")
        notes_parts.append("Must establish: (1) duty of care, (2) breach of duty, (3) causation, (4) damages.")
        notes_parts.append("Focus on expert testimony to establish standard of care.")
        notes_parts.append("Document all damages thoroughly with supporting evidence.")
    else:
        notes_parts.append("Civil case requiring preponderance of evidence standard.")
        notes_parts.append("Clearly establish all elements of the claim with documentary and testimonial evidence.")
        notes_parts.append("Anticipate and prepare to counter opposing party's defenses.")
    
    notes = " ".join(notes_parts)
    
    # Generate relevant evidence items
    evidence = []
    
    if 'malpractice' in issue or 'medical' in issue:
        evidence.extend([
            {
                "name": "Medical Records and Treatment History",
                "content": "Complete medical documentation including all treatment notes, test results, prescriptions, and procedural records",
                "type": "document",
                "relevance": "Establishes the timeline of care and treatment decisions made by healthcare providers"
            },
            {
                "name": "Expert Medical Testimony",
                "content": "Board-certified medical expert in the relevant specialty to testify regarding standard of care",
                "type": "expert",
                "relevance": "Critical for establishing what a reasonable practitioner would have done in similar circumstances"
            },
            {
                "name": "Hospital Policies and Procedures",
                "content": "Internal protocols and guidelines that were in effect at the time of treatment",
                "type": "document",
                "relevance": "Demonstrates whether institutional standards were followed or breached"
            }
        ])
    
    evidence.extend([
        {
            "name": "Witness Statements and Depositions",
            "content": "Sworn testimony from all individuals with direct knowledge of the relevant events",
            "type": "testimony",
            "relevance": "Provides first-hand accounts and corroborates or contradicts other evidence"
        },
        {
            "name": "Documentary Evidence",
            "content": "All relevant contracts, correspondence, records, and written materials related to the case",
            "type": "document",
            "relevance": "Establishes facts, timelines, and relationships between parties"
        },
        {
            "name": "Physical and Demonstrative Evidence",
            "content": "Photographs, videos, physical objects, diagrams, and models that illustrate key facts",
            "type": "physical",
            "relevance": "Provides tangible proof and helps jury understand complex or technical matters"
        }
    ])
    
    # Generate relevant precedents
    precedents = []
    
    if 'negligence' in issue or 'tort' in case_type:
        precedents.extend([
            "Donoghue v. Stevenson (1932) - Established the modern concept of duty of care in negligence law, holding that manufacturers owe a duty to consumers even without direct contractual relationship",
            "Palsgraf v. Long Island Railroad Co. (1928) - Defined proximate cause and foreseeability in negligence, limiting liability to foreseeable plaintiffs within the zone of danger",
            "Vaughan v. Menlove (1837) - Established the objective reasonable person standard for determining breach of duty in negligence cases"
        ])
    
    if 'malpractice' in issue:
        precedents.extend([
            "Canterbury v. Spence (1972) - Established the informed consent doctrine requiring physicians to disclose material risks, shifting from professional to patient-based standard",
            "Helling v. Carey (1974) - Held that compliance with professional standards may be insufficient if reasonable prudence requires additional precautions"
        ])
    
    if 'criminal' in case_type:
        precedents.extend([
            "Miranda v. Arizona (1966) - Established requirement for police to inform suspects of their constitutional rights before custodial interrogation",
            "Brady v. Maryland (1963) - Requires prosecution to disclose material exculpatory evidence to the defense"
        ])
    
    # Add general precedents if none added yet
    if not precedents:
        precedents.extend([
            "Review controlling case law from the jurisdiction where this case will be heard",
            "Consider analogous cases from other jurisdictions with persuasive authority",
            "Analyze recent decisions that may have modified or clarified relevant legal principles"
        ])
    
    return {
        "notes": notes,
        "evidence": evidence,
        "precedents": precedents
    }

def main():
    print("\\n" + "="*60)
    print(f"AI-POWERED LEGAL ANALYSIS: {case_data['title']}")
    print("="*60 + "\\n")
    
    output = None
    
    # Try API-powered analysis first
    if OPENROUTER_API_KEY and OPENROUTER_API_KEY != "":
        print("ü§ñ Generating AI-powered insights with GPT-4o...")
        print()
        try:
            insights = call_openrouter_api()
            
            if insights and isinstance(insights, dict):
                output = {
                    "notes": insights.get("notes", ""),
                    "evidence": insights.get("evidence", []),
                    "precedents": insights.get("precedents", [])
                }
                print("‚úÖ AI-powered analysis completed successfully")
            else:
                print("‚ö†Ô∏è  API returned invalid data, using enhanced fallback analysis")
                output = generate_fallback_analysis()
        except Exception as api_error:
            print(f"‚ö†Ô∏è  API call error: {str(api_error)}")
            print("Using enhanced fallback analysis instead")
            output = generate_fallback_analysis()
    else:
        print("‚ö†Ô∏è  No OpenRouter API key configured, using enhanced fallback analysis")
        output = generate_fallback_analysis()
    
    # Ensure we always have valid output
    if not output:
        print("‚ö†Ô∏è  Generating emergency fallback analysis")
        output = generate_fallback_analysis()
    
    # Display results
    print("üìù STRATEGIC NOTES:")
    print(output["notes"])
    print()
    
    print("üìã EVIDENCE ITEMS:")
    for i, ev in enumerate(output["evidence"], 1):
        print(f"\\n{i}. {ev['name']} ({ev['type']})")
        print(f"   {ev['content']}")
        print(f"   Relevance: {ev['relevance']}")
    print()
    
    print("‚öñÔ∏è  LEGAL PRECEDENTS:")
    for i, prec in enumerate(output["precedents"], 1):
        print(f"{i}. {prec}")
    print()
    
    print("="*60)
    print("‚úì Analysis complete - Insights ready for battle")
    print("="*60 + "\\n")
    
    # Save to file
    with open('analysis_output.json', 'w') as f:
        json.dump(output, f, indent=2)
    
    print("üíæ Results saved to: analysis_output.json")

if __name__ == "__main__":
    main()
`;
}

/**
 * Create a Daytona sandbox with legal case analysis files
 */
export async function createCaseSandbox(caseData) {
  try {
    const daytona = getDaytona();
    
    // Create sandbox with Python environment
    const sandbox = await daytona.create({
      language: 'python',
      envVars: {
        CASE_ID: String(caseData.id),
        CASE_TITLE: caseData.title,
        CASE_TYPE: caseData.case_type,
        LEGAL_ISSUE: caseData.issue,
      },
      // Optional: Set auto-stop after 30 minutes of inactivity
      autoStopInterval: 30,
      // Optional: Set sandbox class for resources
      class: 'medium'
    });

    // Wait for sandbox to be ready
    await sandbox.waitUntilStarted();

    // Create case analysis files
    const caseAnalysis = generateCaseAnalysisMarkdown(caseData);
    const pythonScript = generatePythonAnalysisScript(caseData);

    // Upload files to sandbox
    await sandbox.fs.uploadFiles([
      {
        source: Buffer.from(caseAnalysis, 'utf-8'),
        destination: 'case_analysis.md'
      },
      {
        source: Buffer.from(pythonScript, 'utf-8'),
        destination: 'legal_research.py'
      },
      {
        source: Buffer.from(`# LeetCourt Case ${caseData.id}

This sandbox contains:
- \`case_analysis.md\` - Full case details
- \`legal_research.py\` - Python analysis script

Run the analysis:
\`\`\`bash
python3 legal_research.py
\`\`\`
`, 'utf-8'),
        destination: 'README.md'
      }
    ]);

    // Make the Python script executable
    await sandbox.fs.setFilePermissions('legal_research.py', { mode: '755' });

    // Create SSH access for the user (valid for 60 minutes)
    const sshAccess = await sandbox.createSshAccess(60);

    // Run the Python script to generate initial analysis
    const analysisResult = await sandbox.process.executeCommand('python3 legal_research.py');
    
    console.log('Python script execution result:', analysisResult);

    // Download the JSON output with insights
    let jsonOutput;
    try {
      const jsonOutputBuffer = await sandbox.fs.downloadFile('analysis_output.json');
      jsonOutput = JSON.parse(jsonOutputBuffer.toString('utf-8'));
    } catch (fileError) {
      console.error('Failed to download analysis_output.json:', fileError);
      console.error('Python script output:', analysisResult.result);
      throw new Error(`Analysis failed: ${analysisResult.result || 'Python script did not generate output file'}`);
    }

    return {
      success: true,
      sshCommand: sshAccess.sshCommand,
      // Return structured insights for ToolsPanel
      insights: {
        notes: jsonOutput.notes,
        evidence: jsonOutput.evidence,
        precedents: jsonOutput.precedents
      }
    };

  } catch (error) {
    console.error('Daytona integration error:', error);
    
    // Provide specific error messages
    let errorMessage = error.message;
    let instructions = [];
    
    if (error.message.includes('Analysis failed')) {
      // Python script execution failed
      errorMessage = 'AI analysis failed to complete';
      instructions = [
        'The sandbox was created but the Python script encountered an error',
        'This may be due to:',
        '  - OpenRouter API key not configured or invalid',
        '  - Network connectivity issues',
        '  - Insufficient API credits',
        'Check browser console for detailed error logs'
      ];
    } else if (error.message.includes('API key') || error.message.includes('authentication')) {
      // API key issues
      instructions = [
        'Make sure you have set VITE_DAYTONA_API_KEY in your .env file',
        'Log in to Daytona and create an API key at: https://app.daytona.io',
        'Add to .env: VITE_DAYTONA_API_KEY=your_api_key_here',
        'Restart your dev server after updating .env'
      ];
    } else {
      // Generic error
      instructions = [
        'An unexpected error occurred while creating the sandbox',
        'Check your internet connection',
        'Verify your Daytona API key is valid',
        'Check browser console for detailed error logs'
      ];
    }
    
    return {
      success: false,
      error: errorMessage,
      instructions
    };
  }
}

/**
 * Get Daytona configuration status
 */
export function getDaytonaStatus() {
  const apiKey = import.meta.env.VITE_DAYTONA_API_KEY;
  const apiUrl = import.meta.env.VITE_DAYTONA_API_URL;
  
  return {
    configured: !!apiKey,
    apiUrl: apiUrl || 'https://app.daytona.io/api',
    instructions: !apiKey ? [
      '1. Sign up at https://app.daytona.io',
      '2. Create an API key in your account settings',
      '3. Add VITE_DAYTONA_API_KEY to your .env file',
      '4. Restart your dev server'
    ] : null
  };
}
